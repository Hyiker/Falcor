#include <execution>
#include "GraphPartitioner.h"
#include "Utils/Math/FalcorMath.h"
#include "Utils/Algorithm/RadixSort.h"
#include <metis.h>
namespace Falcor
{

GraphPartitioner::GraphPartitioner(uint32_t numElements) : mIndices(numElements), mNumElements(numElements)
{
    for (uint32_t i = 0; i < numElements; i++)
    {
        mIndices[i] = i;
    }
}

std::unique_ptr<GraphPartitioner::GraphData> GraphPartitioner::createGraph(uint32_t numAdjacency) const
{
    return std::make_unique<GraphData>(*const_cast<GraphPartitioner*>(this), numAdjacency, mNumElements);
}

void GraphPartitioner::buildLocalityLinks(
    DisjointSet& disjointSet,
    fstd::span<const uint32_t> groupIndices,
    const AABB& bounds,
    std::function<float3(uint32_t)> getCenter
)
{
    std::vector<uint32_t> sortKeys(mNumElements);
    mSortedIndices.resize(mNumElements);

    const bool useGroupIndices = !groupIndices.empty();

    FALCOR_CHECK(!useGroupIndices, "Group indices are not supported yet");

    // 1. Build sortKeys, keys are generated by computing the Morton Code of
    //    the local center of the triangle.
    // TODO: parallelize this
    float3 boundsBox = bounds.maxPoint - bounds.minPoint;
    float boundsBoxMax = std::max(boundsBox.x, std::max(boundsBox.y, boundsBox.z));
    std::iota(sortKeys.begin(), sortKeys.end(), 0);
    std::for_each(
        std::execution::par_unseq,
        sortKeys.begin(),
        sortKeys.end(),
        [&](uint32_t& i)
        {
            float3 center = getCenter(i);
            center = (center - bounds.minPoint) / boundsBoxMax;

            uint32_t morton;
            morton = mortonCode(uint32_t(center.x * 1023.0f));
            morton |= mortonCode(uint32_t(center.y * 1023.0f)) << 1;
            morton |= mortonCode(uint32_t(center.z * 1023.0f)) << 2;
            i = morton;
        }
    );

    // 2. Radix sort
    //    Sort the indices to sorted indices by the morton code.
    radixSort32(mSortedIndices.data(), mIndices.data(), mNumElements, [&](uint32_t i) { return sortKeys[i]; });
    sortKeys.clear();
    std::swap(mIndices, mSortedIndices);
    for (uint32_t i = 0; i < mNumElements; i++)
    {
        mSortedIndices[mIndices[i]] = i;
    }

    // 3. Island runs
    //    Run length acceleration
    std::vector<Range> islandRuns(mNumElements);

    // Run length acceleration
    // Range of identical IslandID denoting that elements are connected.
    // Used for jumping past connected elements to the next nearby disjoint element.
    {
        uint32_t runIslandID = 0;
        uint32_t runFirstElement = 0;

        for (uint32_t i = 0; i < mNumElements; i++)
        {
            uint32_t islandID = disjointSet.find(mIndices[i]);

            if (runIslandID != islandID)
            {
                // We found the end so rewind to the beginning of the run and fill.
                for (uint32_t j = runFirstElement; j < i; j++)
                {
                    islandRuns[j].second = i - 1;
                }

                // Start the next run
                runIslandID = islandID;
                runFirstElement = i;
            }

            islandRuns[i].first = runFirstElement;
        }
        // Finish the last run
        for (uint32_t j = runFirstElement; j < mNumElements; j++)
        {
            islandRuns[j].second = mNumElements - 1;
        }
    }

    // 4. Build locality links
    //    For each element, find the closest elements and add them to the locality links.
    for (uint32_t i = 0; i < mNumElements; i++)
    {
        uint32_t index = mIndices[i];

        uint32_t runLength = islandRuns[i].second - islandRuns[i].first + 1;
        if (runLength < 128)
        {
            uint32_t islandID = disjointSet[index];
            // int32_t GroupID = bElementGroups ? GroupIndexes[Index] : 0;

            float3 center = getCenter(index);

            constexpr uint32_t kMaxLinksPerElement = 5;

            std::array<uint32_t, kMaxLinksPerElement> closestIndex;
            std::array<float, kMaxLinksPerElement> closestDist2;
            for (int k = 0; k < kMaxLinksPerElement; k++)
            {
                closestIndex[k] = ~0u;
                closestDist2[k] = std::numeric_limits<float>::max();
            }

            for (int direction = 0; direction < 2; direction++)
            {
                uint32_t limit = direction ? mNumElements - 1 : 0;
                uint32_t Step = direction ? 1 : -1;

                uint32_t adj = i;
                for (int iterations = 0; iterations < 16; iterations++)
                {
                    if (adj == limit)
                        break;
                    adj += Step;

                    uint32_t adjIndex = mIndices[adj];
                    uint32_t adjIslandID = disjointSet[adjIndex];
                    // int32 AdjGroupID = bElementGroups ? GroupIndexes[AdjIndex] : 0;
                    if (islandID == adjIslandID)
                    {
                        // Skip past this run
                        if (direction)
                            adj = islandRuns[adj].second;
                        else
                            adj = islandRuns[adj].first;
                    }
                    else
                    {
                        // Add to sorted list
                        float3 adjDir = center - getCenter(adjIndex);
                        float adjDist2 = dot(adjDir, adjDir);
                        for (int k = 0; k < kMaxLinksPerElement; k++)
                        {
                            if (adjDist2 < closestDist2[k])
                            {
                                std::swap(adjIndex, closestIndex[k]);
                                std::swap(adjDist2, closestDist2[k]);
                            }
                        }
                    }
                }
            }

            for (int k = 0; k < kMaxLinksPerElement; k++)
            {
                if (closestIndex[k] != ~0u)
                {
                    // Add both directions
                    mLocalityLinks.emplace(index, closestIndex[k]);
                    mLocalityLinks.emplace(closestIndex[k], index);
                }
            }
        }
    }
}
void GraphPartitioner::partition(GraphData& graph, uint32_t minPartitionSize, uint32_t maxPartitionSize)
{
    const int kTargetPartitionSize = (minPartitionSize + maxPartitionSize) / 2;
    const int kTargetNumPartitions = div_round_up(graph.num, kTargetPartitionSize);

    if (kTargetNumPartitions > 1)
    {
        mPartitionIDs.resize(mNumElements);

        idx_t numConstraints = 1;
        idx_t numParts = kTargetNumPartitions;
        idx_t edgesCut = 0;

        idx_t options[METIS_NOPTIONS];
        METIS_SetDefaultOptions(options);

        options[METIS_OPTION_UFACTOR] = 200; //( 1000 * MaxPartitionSize * TargetNumPartitions ) / NumElements - 1000;
        // options[ METIS_OPTION_NCUTS ] = 8;
        // options[ METIS_OPTION_IPTYPE ] = METIS_IPTYPE_RANDOM;
        // options[ METIS_OPTION_SEED ] = 17;

        // int r = METIS_PartGraphRecursive(
        int r = METIS_PartGraphKway(
            &graph.num,
            &numConstraints, // number of balancing constraints
            graph.adjOffset.data(),
            graph.adj.data(),
            nullptr,              // Vert weights
            nullptr,              // Vert sizes for computing the total communication volume
            graph.adjCost.data(), // Edge weights
            &numParts,
            nullptr, // Target partition weight
            nullptr, // Allowed load imbalance tolerance
            options,
            &edgesCut,
            mPartitionIDs.data()
        );
        FALCOR_CHECK(r == METIS_OK, "METIS partitioning failed, error code: {}", r);
        std::vector<uint32_t> elementCount(kTargetNumPartitions, 0);

        for (auto partitionID : mPartitionIDs)
        {
            elementCount[partitionID]++;
        }

        uint32_t begin = 0;
        mRanges.resize(kTargetNumPartitions);
        for (int partitionIndex = 0; partitionIndex < kTargetNumPartitions; partitionIndex++)
        {
            mRanges[partitionIndex] = std::make_pair(begin, begin + elementCount[partitionIndex]);
            begin += elementCount[partitionIndex];
            elementCount[partitionIndex] = 0;
        }

        std::vector<uint32_t> oldIndices(mNumElements);
        std::swap(mIndices, oldIndices);

        // reorder indices
        for (uint32_t i = 0; i < mNumElements; i++)
        {
            uint32_t partitionIndex = mPartitionIDs[i];
            uint32_t offset = mRanges[partitionIndex].first;
            uint32_t num = elementCount[partitionIndex]++;

            mIndices[offset + num] = oldIndices[i];
        }

        mPartitionIDs.clear();
    }
    else
    {
        // Single
        mRanges.emplace_back(0, mNumElements);
    }

    for (uint32_t i = 0; i < mNumElements; i++)
    {
        mSortedIndices[mIndices[i]] = i;
    }
}
} // namespace Falcor

#include <execution>
#include "GraphPartitioner.h"
#include "Utils/Math/FalcorMath.h"
#include "Utils/Algorithm/RadixSort.h"
#include "metis.h"
namespace Falcor
{

GraphPartitioner::GraphPartitioner(uint32_t numElements) : mIndices(numElements), mNumElements(numElements)
{
    for (uint32_t i = 0; i < numElements; i++)
    {
        mIndices[i] = i;
    }
}

std::unique_ptr<GraphPartitioner::GraphData> GraphPartitioner::createGraph(uint32_t numAdjacency) const
{
    return std::make_unique<GraphData>(*const_cast<GraphPartitioner*>(this), numAdjacency, mNumElements);
}

void GraphPartitioner::buildLocalityLinks(
    DisjointSet& disjointSet,
    fstd::span<const uint32_t> groupIndices,
    const AABB& bounds,
    std::function<float3(uint32_t)> getCenter
)
{
    std::vector<uint32_t> sortKeys(mNumElements);
    mSortedIndices.resize(mNumElements);

    const bool useGroupIndices = !groupIndices.empty();

    FALCOR_CHECK(!useGroupIndices, "Group indices are not supported yet");

    // 1. Build sortKeys, keys are generated by computing the Morton Code of
    //    the local center of the triangle.
    // TODO: parallelize this
    float3 boundsBox = bounds.maxPoint - bounds.minPoint;
    float boundsBoxMax = std::max(boundsBox.x, std::max(boundsBox.y, boundsBox.z));
    std::iota(sortKeys.begin(), sortKeys.end(), 0);
    std::for_each(
        std::execution::par_unseq,
        sortKeys.begin(),
        sortKeys.end(),
        [&](uint32_t& i)
        {
            float3 center = getCenter(i);
            center = (center - bounds.minPoint) / boundsBoxMax;

            uint32_t morton;
            morton = mortonCode(uint32_t(center.x * 1023.0f));
            morton |= mortonCode(uint32_t(center.y * 1023.0f)) << 1;
            morton |= mortonCode(uint32_t(center.z * 1023.0f)) << 2;
            i = morton;
        }
    );

    // 2. Radix sort
    //    Sort the indices to sorted indices by the morton code.
    radixSort32(mSortedIndices.data(), mIndices.data(), mNumElements, [&](uint32_t i) { return sortKeys[i]; });
    sortKeys.clear();
    std::swap(mIndices, mSortedIndices);
    for (uint32_t i = 0; i < mNumElements; i++)
    {
        mSortedIndices[mIndices[i]] = i;
    }

    // 3. Island runs
    //    Run length acceleration
    std::vector<Range> islandRuns(mNumElements);

    // Run length acceleration
    // Range of identical IslandID denoting that elements are connected.
    // Used for jumping past connected elements to the next nearby disjoint element.
    {
        uint32_t runIslandID = 0;
        uint32_t runFirstElement = 0;

        for (uint32_t i = 0; i < mNumElements; i++)
        {
            uint32_t islandID = disjointSet.find(mIndices[i]);

            if (runIslandID != islandID)
            {
                // We found the end so rewind to the beginning of the run and fill.
                for (uint32_t j = runFirstElement; j < i; j++)
                {
                    islandRuns[j].second = i - 1;
                }

                // Start the next run
                runIslandID = islandID;
                runFirstElement = i;
            }

            islandRuns[i].first = runFirstElement;
        }
        // Finish the last run
        for (uint32_t j = runFirstElement; j < mNumElements; j++)
        {
            islandRuns[j].second = mNumElements - 1;
        }
    }

    // 4. Build locality links
    //    For each element, find the closest elements and add them to the locality links.
    for (uint32_t i = 0; i < mNumElements; i++)
    {
        uint32_t index = mIndices[i];

        uint32_t runLength = islandRuns[i].second - islandRuns[i].first + 1;
        if (runLength < 128)
        {
            uint32_t islandID = disjointSet[index];
            // int32_t GroupID = bElementGroups ? GroupIndexes[Index] : 0;

            float3 center = getCenter(index);

            constexpr uint32_t kMaxLinksPerElement = 5;

            std::array<uint32_t, kMaxLinksPerElement> closestIndex;
            std::array<float, kMaxLinksPerElement> closestDist2;
            for (int k = 0; k < kMaxLinksPerElement; k++)
            {
                closestIndex[k] = ~0u;
                closestDist2[k] = std::numeric_limits<float>::max();
            }

            for (int direction = 0; direction < 2; direction++)
            {
                uint32_t limit = direction ? mNumElements - 1 : 0;
                uint32_t Step = direction ? 1 : -1;

                uint32_t adj = i;
                for (int iterations = 0; iterations < 16; iterations++)
                {
                    if (adj == limit)
                        break;
                    adj += Step;

                    uint32_t adjIndex = mIndices[adj];
                    uint32_t adjIslandID = disjointSet[adjIndex];
                    // int32 AdjGroupID = bElementGroups ? GroupIndexes[AdjIndex] : 0;
                    if (islandID == adjIslandID)
                    {
                        // Skip past this run
                        if (direction)
                            adj = islandRuns[adj].second;
                        else
                            adj = islandRuns[adj].first;
                    }
                    else
                    {
                        // Add to sorted list
                        float3 adjDir = center - getCenter(adjIndex);
                        float adjDist2 = dot(adjDir, adjDir);
                        for (int k = 0; k < kMaxLinksPerElement; k++)
                        {
                            if (adjDist2 < closestDist2[k])
                            {
                                std::swap(adjIndex, closestIndex[k]);
                                std::swap(adjDist2, closestDist2[k]);
                            }
                        }
                    }
                }
            }

            for (int k = 0; k < kMaxLinksPerElement; k++)
            {
                if (closestIndex[k] != ~0u)
                {
                    // Add both directions
                    mLocalityLinks.emplace(index, closestIndex[k]);
                    mLocalityLinks.emplace(closestIndex[k], index);
                }
            }
        }
    }
}
void GraphPartitioner::partition(GraphData& graph, uint32_t minPartitionSize, uint32_t maxPartitionSize) const {}
} // namespace Falcor
